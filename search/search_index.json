{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to RCJ Soccer Sim! The RoboCupJunior Soccer Simulator is an attempt at playing RoboCupJunior Soccer in a virtualized environment. It is an experimental project organized by the RoboCupJunior Soccer Technical Committe. The simulator is based on Webots . The associated repository provides both the \"automatic referee\" (which implements the Soccer Simulated Rules ) as well as a sample team of robots with some basic simulated strategy. How do I try this out? Installation Install Python 3.7 (or higher) 64 bit from the official website (please make sure it is version 3.7 or higher for Windows, and 3.8 or higher if installing on MacOS or Linux). On Windows, please make sure your Python is referenced in Windows PATH by selecting the option \"Add Python 3.x to PATH\" during the installation. Check out this great installation guide if you need some help! Download Webots from their official website. Currently, version r2021a is stable with the Soccer Simulator. You can find detailed installation procedure on the official Webots Installation guide . Clone the rcj-soccer-sim repository to your computer by downloading the ZIP file from here or running git clone https://github.com/RoboCupJuniorTC/rcj-soccer-sim.git Finally, run Webots, go to Tools > Preferences > Python command and set it to python or python3 to point Webots to Python 3. Depending on your system, the reference to Python 3 can be via the command python or python3 . More information on how to configure Webots to work with Python can be found here . Running Soccer Sim Use Webots to open the downloaded soccer.wbt world located in the worlds directory (via File > Open World ) Run/pause the simulation by clicking the corresponding buttons on the top-part of Webots window. Note that the controllers that are responsible for the various robots on the field can be found in the controllers/ directory. Notes A specific webots world can be executed directly from the command line as follows: webots --mode=run worlds/soccer.wbt Which allows for at least some automation. Further info can be found in the docs . The sample players as well as the \"automatic referee\" are implemented in Python, which should allow for easily updating the code to match the rules and avoid any compilation issues.","title":"Welcome to RCJ Soccer Sim!"},{"location":"#welcome-to-rcj-soccer-sim","text":"The RoboCupJunior Soccer Simulator is an attempt at playing RoboCupJunior Soccer in a virtualized environment. It is an experimental project organized by the RoboCupJunior Soccer Technical Committe. The simulator is based on Webots . The associated repository provides both the \"automatic referee\" (which implements the Soccer Simulated Rules ) as well as a sample team of robots with some basic simulated strategy.","title":"Welcome to RCJ Soccer Sim!"},{"location":"#how-do-i-try-this-out","text":"","title":"How do I try this out?"},{"location":"#installation","text":"Install Python 3.7 (or higher) 64 bit from the official website (please make sure it is version 3.7 or higher for Windows, and 3.8 or higher if installing on MacOS or Linux). On Windows, please make sure your Python is referenced in Windows PATH by selecting the option \"Add Python 3.x to PATH\" during the installation. Check out this great installation guide if you need some help! Download Webots from their official website. Currently, version r2021a is stable with the Soccer Simulator. You can find detailed installation procedure on the official Webots Installation guide . Clone the rcj-soccer-sim repository to your computer by downloading the ZIP file from here or running git clone https://github.com/RoboCupJuniorTC/rcj-soccer-sim.git Finally, run Webots, go to Tools > Preferences > Python command and set it to python or python3 to point Webots to Python 3. Depending on your system, the reference to Python 3 can be via the command python or python3 . More information on how to configure Webots to work with Python can be found here .","title":"Installation"},{"location":"#running-soccer-sim","text":"Use Webots to open the downloaded soccer.wbt world located in the worlds directory (via File > Open World ) Run/pause the simulation by clicking the corresponding buttons on the top-part of Webots window. Note that the controllers that are responsible for the various robots on the field can be found in the controllers/ directory.","title":"Running Soccer Sim"},{"location":"#notes","text":"A specific webots world can be executed directly from the command line as follows: webots --mode=run worlds/soccer.wbt Which allows for at least some automation. Further info can be found in the docs . The sample players as well as the \"automatic referee\" are implemented in Python, which should allow for easily updating the code to match the rules and avoid any compilation issues.","title":"Notes"},{"location":"code_submission/","text":"Code submission To play the competition, the code that's powering the team's robots needs to get to the organizers. Let's talk a bit about how to do this. From controllers to a submission Suppose you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py To submit it for the competition, there are two (well, maybe three) things we need to do: 1. Add a team name 2. (Optionally) add a team logo 3. Create a ZIP archive Add a team name The folder structure above does contain some code but it is not immediately obvious which team does it belong to. To make it obvious, please create a file called team_name.txt on the same level as robot/ . This file should contain a single line of text: the name of the team (up to 32 characters). The resulting folder structure would then look as follows: controllers/ \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py \u2514\u2500\u2500 team_name.txt (Optionally) add a team logo Note: This step is completely optional and you can just skip it -- your robot controllers will still work, even if you do not provide a custom logo for your team . If you'd like, you can optionally also add a custom logo for your team's robot. It will be used as an overlay on the robots in the simulator. The logo needs to be stored in the PNG format and located in a file called logo.png . If you choose to add one, the folder structure will look something like the following: controllers/ \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 logo.png \u2514\u2500\u2500 team_name.txt Create a ZIP archive This step is very simple: you just pick the directory that contains the code for your three robots, the team_name.txt file and optionally logo.png and put them all together into a single .ZIP file. There are many utilities that will do the job -- we can recommend 7-Zip . When you look into the resulting .ZIP file, the folder structure should look as follows: . \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 logo.png \u2514\u2500\u2500 team_name.txt Note that there is no controllers/ folder anymore -- the .ZIP file only contains three folders and a single text file called team_name.txt (and optionally logo.png ). Uploading your submission Once you have your .ZIP file ready, the only thing left is to submit it to the organizers. In practice, this generally means uploading it to a specific location that will be shared with all the participating teams well before the submission deadline. Things to keep in mind The resulting .ZIP file can be at most 10MB in size. The .ZIP file you submit needs to have exactly one first-level folder. That is, the folder structure after unzipping cannot look as follows: . \u251c\u2500\u2500 robot1 \u2502 \u2514\u2500\u2500 robot1.py \u251c\u2500\u2500 robot2 \u2502 \u2514\u2500\u2500 robot2.py The tournament organization software would not know which three robots to pick up and would most likely end up picking them up randomly. The organizers will run a code similarity detector on the submitted code. Yes, wheels really do not need to be reinvented but it would really not be fair to win a competition with something that's not primarily the team's own work. Submissions with significant overlap of duplicated code will not be permitted to compete in the competition. The code you submit will be open sourced at the end of the competition. If you managed to find a bug, have any question or ran into some problem, please do not hesitate to ask on the forum .","title":"Code submission"},{"location":"code_submission/#code-submission","text":"To play the competition, the code that's powering the team's robots needs to get to the organizers. Let's talk a bit about how to do this.","title":"Code submission"},{"location":"code_submission/#from-controllers-to-a-submission","text":"Suppose you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py To submit it for the competition, there are two (well, maybe three) things we need to do: 1. Add a team name 2. (Optionally) add a team logo 3. Create a ZIP archive","title":"From controllers to a submission"},{"location":"code_submission/#add-a-team-name","text":"The folder structure above does contain some code but it is not immediately obvious which team does it belong to. To make it obvious, please create a file called team_name.txt on the same level as robot/ . This file should contain a single line of text: the name of the team (up to 32 characters). The resulting folder structure would then look as follows: controllers/ \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py \u2514\u2500\u2500 team_name.txt","title":"Add a team name"},{"location":"code_submission/#optionally-add-a-team-logo","text":"Note: This step is completely optional and you can just skip it -- your robot controllers will still work, even if you do not provide a custom logo for your team . If you'd like, you can optionally also add a custom logo for your team's robot. It will be used as an overlay on the robots in the simulator. The logo needs to be stored in the PNG format and located in a file called logo.png . If you choose to add one, the folder structure will look something like the following: controllers/ \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 logo.png \u2514\u2500\u2500 team_name.txt","title":"(Optionally) add a team logo"},{"location":"code_submission/#create-a-zip-archive","text":"This step is very simple: you just pick the directory that contains the code for your three robots, the team_name.txt file and optionally logo.png and put them all together into a single .ZIP file. There are many utilities that will do the job -- we can recommend 7-Zip . When you look into the resulting .ZIP file, the folder structure should look as follows: . \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py \u251c\u2500\u2500 logo.png \u2514\u2500\u2500 team_name.txt Note that there is no controllers/ folder anymore -- the .ZIP file only contains three folders and a single text file called team_name.txt (and optionally logo.png ).","title":"Create a ZIP archive"},{"location":"code_submission/#uploading-your-submission","text":"Once you have your .ZIP file ready, the only thing left is to submit it to the organizers. In practice, this generally means uploading it to a specific location that will be shared with all the participating teams well before the submission deadline.","title":"Uploading your submission"},{"location":"code_submission/#things-to-keep-in-mind","text":"The resulting .ZIP file can be at most 10MB in size. The .ZIP file you submit needs to have exactly one first-level folder. That is, the folder structure after unzipping cannot look as follows: . \u251c\u2500\u2500 robot1 \u2502 \u2514\u2500\u2500 robot1.py \u251c\u2500\u2500 robot2 \u2502 \u2514\u2500\u2500 robot2.py The tournament organization software would not know which three robots to pick up and would most likely end up picking them up randomly. The organizers will run a code similarity detector on the submitted code. Yes, wheels really do not need to be reinvented but it would really not be fair to win a competition with something that's not primarily the team's own work. Submissions with significant overlap of duplicated code will not be permitted to compete in the competition. The code you submit will be open sourced at the end of the competition. If you managed to find a bug, have any question or ran into some problem, please do not hesitate to ask on the forum .","title":"Things to keep in mind"},{"location":"how_to/","text":"How to program your robot Controllers Each object in the simulation world can be controlled by a program. This program is called Controller . Each robot should have exactly one controller, implemented as a Python3 program. There is an invisible referee object in the simulation, which takes care of controlling the game and checking the rules. The controllers are located in the controllers directory. The name of the controller must be located in a subfolder with the same name (i.e. my_controller/my_controller.py ) and this name ought to be specified in soccer.wbt file. Hello world, robot! We have prepared a few sample robot controllers. They can be found in the controllers directory. The controllers for the robots of blue team are located in rcj_soccer_team_blue folder and for the robots of yellow team in rcj_soccer_team_yellow folder, respectively. Team folders contain a file called rcj_soccer_team_blue.py (blue team) or rcj_soccer_team_yellow.py (yellow team). Each of the robots initially runs this file. Based on the unique identifier of the robot (which can be 1 , 2 or 3 ) we initialize the code for the particular robot. Script for determining and initializing the robot controller A sample initial file might look as follows: from controller import Robot from robot1 import MyRobot1 from robot2 import MyRobot2 from robot3 import MyRobot3 robot = Robot () name = robot . getName () robot_number = int ( name [ 1 ]) if robot_number == 1 : robot_controller = MyRobot1 ( robot ) elif robot_number == 2 : robot_controller = MyRobot2 ( robot ) else : robot_controller = MyRobot3 ( robot ) robot_controller . run () Let's describe a file for determining robot's name and running specific controller. from controller import Robot The Robot class is required to be imported because this is the only way we are able to controll the robot. The Robot class is shipped together with Webots. from robot1 import MyRobot1 from robot2 import MyRobot2 from robot3 import MyRobot3 Since all of robot controllers are located in the same directory, we can easily import them. robot = Robot () name = robot . getName () Initialize robot instance and get the name of the robot. The name is one of the following {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . robot_number = int ( name [ 1 ]) if robot_number == 1 : robot_controller = MyRobot1 ( robot ) elif robot_number == 2 : robot_controller = MyRobot2 ( robot ) else : robot_controller = MyRobot3 ( robot ) By checking the second character in the name, we can easily get the number identifier of the robot and initialize its controller appropriately. robot_controller . run () We just call the method run in order to execute the code for the specific robot we initialized previously. Robot controller Let's put together a simple program to showcase how you can go about programming a robot. import struct TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) class MyRobot : def __init__ ( self , robot ): self . robot = robot self . name = self . robot . getName () self . receiver = self . robot . getDevice ( \"receiver\" ) self . receiver . enable ( TIME_STEP ) self . left_motor = self . robot . getDevice ( \"left wheel motor\" ) self . right_motor = self . robot . getDevice ( \"right wheel motor\" ) self . left_motor . setPosition ( float ( '+inf' )) self . right_motor . setPosition ( float ( '+inf' )) self . left_motor . setVelocity ( 0.0 ) self . right_motor . setVelocity ( 0.0 ) def get_new_data ( self ): packet = self . receiver . getData () self . receiver . nextPacket () struct_fmt = 'ddd' * 6 + 'dd' + '?' unpacked = struct . unpack ( struct_fmt , packet ) data = {} for i , r in enumerate ( ROBOT_NAMES ): data [ r ] = { \"x\" : unpacked [ 3 * i ], \"y\" : unpacked [ 3 * i + 1 ], \"orientation\" : unpacked [ 3 * i + 2 ] } ball_data_index = 3 * N_ROBOTS data [ \"ball\" ] = { \"x\" : unpacked [ ball_data_index ], \"y\" : unpacked [ ball_data_index + 1 ] } waiting_for_kickoff_data_index = ball_data_index + 2 data [ \"waiting_for_kickoff\" ] = unpacked [ waiting_for_kickoff_data_index ] return data def run ( self ): while self . robot . step ( TIME_STEP ) != - 1 : if self . receiver . getQueueLength () > 0 : data = self . get_new_data () # Get the position of our robot robot_pos = data [ self . name ] # Get the position of the ball ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) Let's explain the code in detail: import struct This library is a built-in Python library , which is required to unpack the data sent by the supervisor. TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) We also define some useful constants, whose values will be used later. class MyRobot : You can wrap the program into the class as we did. The benefit of OOP ( Object Oriented Programming ) is that you can later reuse the same common class throughout your controllers and therefore make the code easier to read. We are going to continue with our OOP approach. def __init__ ( self , robot ): self . robot = Robot self . name = self . robot . getName () ... The __init__ function is something like a constructor of the class and is called when an instance of the MyRobot object is created. We use this function to initialize some important variables. The most important one is the Robot instance, which allows us to get access to the so called Webots devices like motor (for controlling the speed) or receiver (for reading data from Supervisor). The name and the team of your robot can be determined by calling self.robot.getName() . It will give you one of {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . The first letter determines the team (\"Blue\", \"Yellow\"), while the second one is the robot's identifier. def get_new_data ( self ): ... We are not going to explain this deeply. This function is to parse the incoming data from supervisor. Feel free to copy and use it. The resulting dictionary contains positions of all of the robots as well as the position of the ball. Moreover, it contains information whether the goal gets scored and we are waiting for new kickoff. In case the goal gets scored, the value is True and is reset to False when the referee fires new kickoff. def run ( self ): This is the method which contains the logic for controlling the robot. As mentioned previously, it is called by our initialization script. while self . robot . step ( TIME_STEP ) != - 1 : The step function is crucial and must be used in every controller. This function synchronizes the sensor and actuator data between Webots and the controllers. if self . receiver . getQueueLength () > 0 : Before reading data, it is important to check if there is actually something in the queue that we can read. data = self . get_new_data () robot_pos = data [ self . name ] ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) And finally, after reading the new data received from supervisor, we do some calculations and set the speed of the motors. Importing shared code Each team consists of three robots. These robots might share some of the code and it is actually a good practice not to duplicate code all over the place. Imagine you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 team_name/ \u2502 \u2514\u2500\u2500 team_name.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py and within robot1.py , robot2.py and robot3.py you want to import some useful code from utils.py . You can easily import it by calling import utils and use the shared code rather than copying it into each of the controllers. Do not import anything from team_name.py file, otherwise you might get cyclic import problem.","title":"How to program your robot"},{"location":"how_to/#how-to-program-your-robot","text":"","title":"How to program your robot"},{"location":"how_to/#controllers","text":"Each object in the simulation world can be controlled by a program. This program is called Controller . Each robot should have exactly one controller, implemented as a Python3 program. There is an invisible referee object in the simulation, which takes care of controlling the game and checking the rules. The controllers are located in the controllers directory. The name of the controller must be located in a subfolder with the same name (i.e. my_controller/my_controller.py ) and this name ought to be specified in soccer.wbt file.","title":"Controllers"},{"location":"how_to/#hello-world-robot","text":"We have prepared a few sample robot controllers. They can be found in the controllers directory. The controllers for the robots of blue team are located in rcj_soccer_team_blue folder and for the robots of yellow team in rcj_soccer_team_yellow folder, respectively. Team folders contain a file called rcj_soccer_team_blue.py (blue team) or rcj_soccer_team_yellow.py (yellow team). Each of the robots initially runs this file. Based on the unique identifier of the robot (which can be 1 , 2 or 3 ) we initialize the code for the particular robot.","title":"Hello world, robot!"},{"location":"how_to/#script-for-determining-and-initializing-the-robot-controller","text":"A sample initial file might look as follows: from controller import Robot from robot1 import MyRobot1 from robot2 import MyRobot2 from robot3 import MyRobot3 robot = Robot () name = robot . getName () robot_number = int ( name [ 1 ]) if robot_number == 1 : robot_controller = MyRobot1 ( robot ) elif robot_number == 2 : robot_controller = MyRobot2 ( robot ) else : robot_controller = MyRobot3 ( robot ) robot_controller . run () Let's describe a file for determining robot's name and running specific controller. from controller import Robot The Robot class is required to be imported because this is the only way we are able to controll the robot. The Robot class is shipped together with Webots. from robot1 import MyRobot1 from robot2 import MyRobot2 from robot3 import MyRobot3 Since all of robot controllers are located in the same directory, we can easily import them. robot = Robot () name = robot . getName () Initialize robot instance and get the name of the robot. The name is one of the following {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . robot_number = int ( name [ 1 ]) if robot_number == 1 : robot_controller = MyRobot1 ( robot ) elif robot_number == 2 : robot_controller = MyRobot2 ( robot ) else : robot_controller = MyRobot3 ( robot ) By checking the second character in the name, we can easily get the number identifier of the robot and initialize its controller appropriately. robot_controller . run () We just call the method run in order to execute the code for the specific robot we initialized previously.","title":"Script for determining and initializing the robot controller"},{"location":"how_to/#robot-controller","text":"Let's put together a simple program to showcase how you can go about programming a robot. import struct TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) class MyRobot : def __init__ ( self , robot ): self . robot = robot self . name = self . robot . getName () self . receiver = self . robot . getDevice ( \"receiver\" ) self . receiver . enable ( TIME_STEP ) self . left_motor = self . robot . getDevice ( \"left wheel motor\" ) self . right_motor = self . robot . getDevice ( \"right wheel motor\" ) self . left_motor . setPosition ( float ( '+inf' )) self . right_motor . setPosition ( float ( '+inf' )) self . left_motor . setVelocity ( 0.0 ) self . right_motor . setVelocity ( 0.0 ) def get_new_data ( self ): packet = self . receiver . getData () self . receiver . nextPacket () struct_fmt = 'ddd' * 6 + 'dd' + '?' unpacked = struct . unpack ( struct_fmt , packet ) data = {} for i , r in enumerate ( ROBOT_NAMES ): data [ r ] = { \"x\" : unpacked [ 3 * i ], \"y\" : unpacked [ 3 * i + 1 ], \"orientation\" : unpacked [ 3 * i + 2 ] } ball_data_index = 3 * N_ROBOTS data [ \"ball\" ] = { \"x\" : unpacked [ ball_data_index ], \"y\" : unpacked [ ball_data_index + 1 ] } waiting_for_kickoff_data_index = ball_data_index + 2 data [ \"waiting_for_kickoff\" ] = unpacked [ waiting_for_kickoff_data_index ] return data def run ( self ): while self . robot . step ( TIME_STEP ) != - 1 : if self . receiver . getQueueLength () > 0 : data = self . get_new_data () # Get the position of our robot robot_pos = data [ self . name ] # Get the position of the ball ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) Let's explain the code in detail: import struct This library is a built-in Python library , which is required to unpack the data sent by the supervisor. TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) We also define some useful constants, whose values will be used later. class MyRobot : You can wrap the program into the class as we did. The benefit of OOP ( Object Oriented Programming ) is that you can later reuse the same common class throughout your controllers and therefore make the code easier to read. We are going to continue with our OOP approach. def __init__ ( self , robot ): self . robot = Robot self . name = self . robot . getName () ... The __init__ function is something like a constructor of the class and is called when an instance of the MyRobot object is created. We use this function to initialize some important variables. The most important one is the Robot instance, which allows us to get access to the so called Webots devices like motor (for controlling the speed) or receiver (for reading data from Supervisor). The name and the team of your robot can be determined by calling self.robot.getName() . It will give you one of {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . The first letter determines the team (\"Blue\", \"Yellow\"), while the second one is the robot's identifier. def get_new_data ( self ): ... We are not going to explain this deeply. This function is to parse the incoming data from supervisor. Feel free to copy and use it. The resulting dictionary contains positions of all of the robots as well as the position of the ball. Moreover, it contains information whether the goal gets scored and we are waiting for new kickoff. In case the goal gets scored, the value is True and is reset to False when the referee fires new kickoff. def run ( self ): This is the method which contains the logic for controlling the robot. As mentioned previously, it is called by our initialization script. while self . robot . step ( TIME_STEP ) != - 1 : The step function is crucial and must be used in every controller. This function synchronizes the sensor and actuator data between Webots and the controllers. if self . receiver . getQueueLength () > 0 : Before reading data, it is important to check if there is actually something in the queue that we can read. data = self . get_new_data () robot_pos = data [ self . name ] ball_pos = data [ 'ball' ] self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) And finally, after reading the new data received from supervisor, we do some calculations and set the speed of the motors.","title":"Robot controller"},{"location":"how_to/#importing-shared-code","text":"Each team consists of three robots. These robots might share some of the code and it is actually a good practice not to duplicate code all over the place. Imagine you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 team_name/ \u2502 \u2514\u2500\u2500 team_name.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py and within robot1.py , robot2.py and robot3.py you want to import some useful code from utils.py . You can easily import it by calling import utils and use the shared code rather than copying it into each of the controllers. Do not import anything from team_name.py file, otherwise you might get cyclic import problem.","title":"Importing shared code"}]}